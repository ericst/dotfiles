# Ghostty shell integration for Bash with full resources caching
GHOSTTY_CACHE_DIR="$HOME/.cache/ghostty"
GHOSTTY_RESOURCES_CACHE="$GHOSTTY_CACHE_DIR/resources-copy"

if [ -n "${GHOSTTY_RESOURCES_DIR}" ]; then
    # Create cache directory if it doesn't exist
    if [ ! -d "$GHOSTTY_CACHE_DIR" ]; then
        mkdir -p "$GHOSTTY_CACHE_DIR"
    fi
    
    # Copy entire resources directory if source is newer or cache doesn't exist
    if [ -d "$GHOSTTY_RESOURCES_DIR" ]; then
        # Check if we need to update the cache
        # We'll use a timestamp file to track when we last synced
        GHOSTTY_SYNC_TIMESTAMP="$GHOSTTY_CACHE_DIR/last-resource-sync"
        NEEDS_SYNC=false
        
        # Check if cache doesn't exist or if source is newer than our last sync
        if [ ! -d "$GHOSTTY_RESOURCES_CACHE" ] || [ ! -f "$GHOSTTY_SYNC_TIMESTAMP" ]; then
            NEEDS_SYNC=true
        elif [ -n "$(find "$GHOSTTY_RESOURCES_DIR" -newer "$GHOSTTY_SYNC_TIMESTAMP" -print -quit 2>/dev/null)" ]; then
            NEEDS_SYNC=true
        fi
        
        if [ "$NEEDS_SYNC" = true ]; then
            # Remove old cache and copy fresh
            rm -rf "$GHOSTTY_RESOURCES_CACHE"
            cp -r "$GHOSTTY_RESOURCES_DIR" "$GHOSTTY_RESOURCES_CACHE"
            # Update sync timestamp
            touch "$GHOSTTY_SYNC_TIMESTAMP"
        fi
    fi
    
    # Clean up variables
    unset GHOSTTY_SYNC_TIMESTAMP NEEDS_SYNC
fi

# Source the cached integration script if it exists, using cached resources
if [ -f "$GHOSTTY_RESOURCES_CACHE/shell-integration/bash/ghostty.bash" ]; then
    export GHOSTTY_RESOURCES_DIR="$GHOSTTY_RESOURCES_CACHE"
    builtin source "$GHOSTTY_RESOURCES_CACHE/shell-integration/bash/ghostty.bash"
fi

unset GHOSTTY_CACHE_DIR GHOSTTY_RESOURCES_CACHE

# Source global definitions
if [ -f /etc/bashrc ]; then
    . /etc/bashrc
fi

# Add some bin folders for my dotfiles
if ! [[ "$PATH" =~ $HOME/shelltape/bin/ ]]; then
    PATH="$HOME/shelltape/bin/:$PATH"
fi

if ! [[ "$PATH" =~ $HOME/.local/bin:$HOME/bin ]]; then
    PATH="$HOME/.local/bin:$HOME/bin:$PATH"
fi

export PATH


# Most of this is taken from the article titled [[https://sanctum.geek.nz/arabesque/better-bash-history/][Better Bash History]].

# First we want to append to the history instead of rewriting it. We also want to
# keep as much as possible into our history.
shopt -s histappend
HISTFILESIZE=1000000
HISTSIZE=1000000


# Of course, not everything is worth saving. For instance duplicate or empty lines
# are not interesting. Setting ~HISTCONTROL~ to the correct value will allow us to
# not save them. Also, some commands, such as the ones used for job control or
# simply listing contents of a directory, are not conveying any particular meaning
HISTCONTROL=ignoreboth
export HISTIGNORE="exit:ls:bg:fg:jobs:history"

# Recording not only the command but also the date at which it was recorded could
# prove useful. Setting ~HISTTIMEFORMAT~ will do just that.
# We also want to make sure that we save multilines together. Those are the shopt
shopt -s cmdhist
shopt -s lithist
HISTTIMEFORMAT='%F %T '

# This is to make sure I don't loose history. It forces bash to write each
# command to the history file immediately.
PROMPT_COMMAND="history -a; $PROMPT_COMMAND"



# Now we only need to make a small alias to search easily into the history.
alias hs="history | grep"


# When using a shell directory navigation is important to put yourself in the
# right context.
# We want bash to help us as much as possible. ~autocd~ allows us to change
# directory by only typing its name without even issuing the ~cd~
# command. ~cdspell~ and ~dirspell~ will auto correct types.
shopt -s autocd
shopt -s dirspell
shopt -s cdspell
CDPATH=":${HOME}:${HOME}/Projects/"

# Here are some safety nets. 

# ~rm~ will refuse to delete ~/~ and prompt confirmation whenever I try to delete
# more than 3 files.
# ~mv~, ~cp~ and ~ln~ will always ask before overwriting anything.
# ~ch{own,mod,grp}~ won't allow me to change permissions on ~/~
alias rm='rm -I --preserve-root'

alias mv='mv -i'
alias cp='cp -i'
alias ln='ln -i'

alias chown='chown --preserve-root'
alias chmod='chmod --preserve-root'
alias chgrp='chgrp --preserve-root'


# My editor of choice is Neovim. Below I set environment variables to make sure
# that it is correctly selected by other applications. I also set an alias to
# edit files quicker.
export ALTERNATE_EDITOR="vi"
export EDITOR="nvim"
export VISUAL="nvim"
export GIT_EDITOR="$EDITOR"
alias e="$VISUAL"

# Also, if I type vim, i meant nvim... If it is installed of course.
if type nvim &> /dev/null; then
    alias vim='nvim'
    export MANPAGER='nvim +Man!' # links man....
fi


# It is nice to have colors automatically in grep.
alias grep='grep --color=auto'


# aliases for listing processes and looking for specific ones
alias ps="ps auxf"
alias psl="ps auxf | less"
alias psg="ps aux | grep -v grep | \grep -i -e VSZ -e"


# Per default I want to create any missing directory.
alias mkdir="mkdir -pv"


# The function ~mkcd~ is extremely useful, to create a directory and immediately
# change to it.
mcd () {
    mkdir -p "$1"
    cd "$1" 
}

# Git status checker function with daily caching
check_git_status() {
    local force_check=false
    local cache_file="$HOME/.cache/dotfiles_git_check"
    local cache_duration=86400  # 24 hours in seconds
    
    # Check for --force flag
    if [[ "$1" == "--force" ]]; then
        force_check=true
    fi
    
    # Create cache directory if it doesn't exist
    mkdir -p "$(dirname "$cache_file")"
    
    # Check if we need to run the full check
    local should_run_full_check=true
    if [[ -f "$cache_file" ]] && [[ "$force_check" != true ]]; then
        local last_check=$(cat "$cache_file" 2>/dev/null || echo "0")
        local current_time=$(date +%s)
        local time_diff=$((current_time - last_check))
        
        if [[ "$time_diff" -lt "$cache_duration" ]]; then
            should_run_full_check=false
        fi
    fi
    
    local original_pwd="$PWD"
    local repos=("$HOME/dotfiles" "$HOME/shelltape")
    local has_issues=false
    
    for repo in "${repos[@]}"; do
        if [[ -d "$repo/.git" ]]; then
            cd "$repo" || continue
            
            local repo_name
            repo_name=$(basename "$repo")
            
            # Always check for local changes (fast operations)
            # Check for uncommitted changes
            if ! git diff-index --quiet HEAD --; then
                echo "$repo_name: You have uncommitted changes"
                has_issues=true
            fi
            
            # Check for untracked files
            if [[ -n $(git ls-files --others --exclude-standard) ]]; then
                echo "$repo_name: You have untracked files"
                has_issues=true
            fi
            
            # Only do expensive remote operations if cache is stale or forced
            if [[ "$should_run_full_check" == true ]]; then
                # Fetch remote updates (quietly) and check if we're behind
                git fetch --quiet 2>/dev/null
                local behind=$(git rev-list --count HEAD..@{u} 2>/dev/null)
                if [[ -n "$behind" && "$behind" -gt 0 ]]; then
                    echo "$repo_name: $behind commit(s) available to pull"
                    has_issues=true
                fi
                
                # Check if we're ahead (have unpushed commits)
                local ahead=$(git rev-list --count @{u}..HEAD 2>/dev/null)
                if [[ -n "$ahead" && "$ahead" -gt 0 ]]; then
                    echo "$repo_name: $ahead commit(s) ready to push"
                    has_issues=true
                fi
            fi
        fi
    done
    
    # Update cache timestamp if we ran the full check
    if [[ "$should_run_full_check" == true ]]; then
        date +%s > "$cache_file"
    fi
    
    if $has_issues; then
        echo "----WARNING----"
    fi
    
    # Return to original directory
    cd "$original_pwd" || true
}

# Helper function to force a git status check
force_git_check() {
    check_git_status --force
}

# Run the check when bash starts (but not for non-interactive shells)
if [[ $- == *i* ]]; then
    check_git_status
fi

#Distrobox integration
workbox() {
    local fedora_version=$(grep -oP 'VERSION_ID=\K\d+' /etc/os-release)
    local image="fedora-toolbox:${fedora_version}"
    
    # Check if container exists without trying to enter it
    if distrobox list | grep -q "workbox"; then
        distrobox enter workbox
    else
        echo "Creating workbox from ${image}..."
        if distrobox create --pull --name workbox --image "${image}"; then
            echo "Container created successfully. Entering workbox..."
            distrobox enter workbox
        else
            echo "Failed to create container"
            return 1
        fi
    fi
}


# Nice aliases
alias wb='workbox'
alias o='xdg-open'

cdtmp(){
    pushd $(mktemp -d)
}


# Source everything into a ~/.bashrc.d.
# TODO move configuration there, to make it nicer
if [ -d ~/.bashrc.d ]; then
    for rc in ~/.bashrc.d/*; do
        if [ -f "$rc" ]; then
            . "$rc"
        fi
    done
fi
unset rc



# References:
# https://sanctum.geek.nz/arabesque/better-bash-history/ - Better Bash History
# https://www.gnu.org/software/bash/manual/html_node/index.html - Bash Reference Manual
# https://tiswww.case.edu/php/chet/readline/readline.html - GNU Readline Library
